import{g as s}from"./assets/storage-DZywevd-.js";async function c(e){const o=await s();if(o){const t=await fetch("https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key="+encodeURIComponent(o),{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({contents:[{role:"user",parts:[{text:e}]}]})});if(!t.ok){const r=await t.text();throw new Error(`Gemini API error: ${t.status} ${r}`)}const a=(await t.json())?.candidates?.[0]?.content?.parts?.[0]?.text??"";if(a)return String(a)}if("LanguageModel"in globalThis&&typeof LanguageModel?.availability=="function"){if(await LanguageModel.availability()==="unavailable")throw new Error("Gemini not available. Ensure flags are enabled and model downloaded.");const a=await(await LanguageModel.create()).prompt(e);return String(a??"")}if("ai"in globalThis){const t=await ai.canCreateTextSession?.();if(t!=="readily")throw new Error(`Gemini not ready: ${t}`);const a=await(await ai.createTextSession()).prompt(e);return String(a??"")}throw new Error("Chrome Prompt API not available. Use Chrome 128+ with flags enabled.")}const l=`You are a browser automation planner.
Given a user request, output a minimal JSON action plan to accomplish it in Chrome.
Rules:
- Respond with ONLY JSON matching {"actions":[...],"rationale":string}.
- Prefer robust CSS selectors for click/type when possible.
- For GitHub starring, use a special {"type":"starGithubRepo","owner":"...","repo":"..."} action.
- Use {"type":"navigate","url":"..."} to open a page.
- Use {"type":"wait","ms":N} when the page needs to settle.
- Do not include comments or markdown.
`;async function u(e){const o=`${l}
User: ${e}
JSON:`,t=await c(o);try{const n=t.indexOf("{"),a=t.lastIndexOf("}"),r=t.slice(n,a+1),i=JSON.parse(r);if(!i?.actions||!Array.isArray(i.actions))throw new Error("Invalid plan");return i}catch(n){return{actions:[],rationale:`Failed to parse plan: ${String(n)}
Raw: ${t}`}}}async function p(){const o=(await chrome.tabs.query({active:!0,currentWindow:!0}))[0];if(!o?.id)throw new Error("No active tab");return o.id}async function d(e,o){const t=[];for(const n of o){t.push(`Run: ${JSON.stringify(n)}`);const a=await chrome.tabs.sendMessage(e,{action:"perform",payload:n});if(a?.error)return t.push(`Error: ${a.error}`),{ok:!1,logs:t};a?.log&&t.push(a.log)}return{ok:!0,logs:t}}chrome.runtime.onMessage.addListener((e,o,t)=>{if(!(!e||typeof e!="object")){if(e.action==="summarizePage")return o.tab?.id==null?void 0:(chrome.tabs.sendMessage(o.tab.id,{action:"summarizePage"},n=>{t(n)}),!0);if(e.action==="agent.planAndRun"){const{command:n}=e;return(async()=>{try{const a=await u(n),r=await p(),i=await d(r,a.actions);t({plan:a,...i})}catch(a){t({error:a?.message??String(a)})}})(),!0}}});
